/* Functions needed to patch the gdbm library */

/* THIS FILE CONTAINS ADDITIONAL FUNCTIONS USED TO FIX THIS LIBRARY */

/* PATCHED VERSION OF GDBM LIBRARY *******************************************
 * This patch is intended to copy the functionality of the 
 * GDBM library as it is found on the SGI platform.
 * The original version of the library created different 
 * fileformats at different platforms. This patched version
 * intends to create the same file at each different platform.
 * The current patched version has been tested for OS X, IRIX,
 * and LINUX. As the original files were all created under
 * IRIX, this patch conforms to the files created at that
 * platform.
 *
 * patch includes:
 * 1) definition of off_t as my_int64_t to be sure that this
 *    field is 8 bytes across platforms. off_t is 4 bytes
 *    on linux and 8 bytes on sgi and osx.
 * 2) includes byteswapping to store the files in the SGI
 *    native format to ensure cross platform compatibility.
 * 3) saving data structures field by field to ensure that
 *    no zero padding is added in between members of these
 *    structures.
 * 4) to add empty dummy fields at those places where the original
 *    SGI version of this library did put additional zeros to have
 *    64 bit integers align properly in memory.
 *
 * notes:
 * the definition of my_int64_t in autoconf.h may need some adjustments
 * in the future to be compatible with more compilers.
 *
 * All lines that have been patched are marked with a PATCH marker
 * the only exception is the conversion of off_t to my_int64_t
 *
 * patch generated by : JG Stinstra
 *
 ****************************************************************************/

#ifndef _WIN32
#include <unistd.h>
#endif
#include "gdbmdefs.h"

#include "gdbmpatch.h"

int patch_isbyteswap()
{
	/* Detect byte swapping
	   This function loads a 2 byte value into test
	   and then tests the values of both bytes to 
	   determine the order in which they are written */

	short test;
	unsigned char *ptr;
	test = 0x00FF;
	ptr = (unsigned char *) &(test);
	if (ptr[0]) return(1); // Bytes are swapped, we must be running on some INTEL machine
	return(0);
}


void patch_swapbytes(void *vbuffer,int elsize,int size)
{
   char temp;
   char *buffer;
   int p;
   
   buffer = (char *)vbuffer;

   size *= elsize;

   switch(elsize)
   {
      case 1:
         /* Do nothing. Element size is 1 byte, so there is nothing to swap */
         break;
      case 2:  
		/* Do a 2 bytes element byte swap */
		for(p=0;p<size;p+=2)
		  { temp = buffer[p]; buffer[p] = buffer[p+1]; buffer[p+1] = temp; }
		break;
      case 4:
		/* Do a 4 bytes element byte swap */
		for(p=0;p<size;p+=4)
		  { temp = buffer[p]; buffer[p] = buffer[p+3]; buffer[p+3] = temp; 
			temp = buffer[p+1]; buffer[p+1] = buffer[p+2]; buffer[p+2] = temp; }
		break;
      case 8:
		/* Do a 8 bytes element byte swap */
		for(p=0;p<size;p+=8)
		  { temp = buffer[p]; buffer[p] = buffer[p+7]; buffer[p+7] = temp; 
			temp = buffer[p+1]; buffer[p+1] = buffer[p+6]; buffer[p+6] = temp; 
			temp = buffer[p+2]; buffer[p+2] = buffer[p+5]; buffer[p+5] = temp; 
			temp = buffer[p+3]; buffer[p+3] = buffer[p+4]; buffer[p+4] = temp; }
   	    break;
   }  
}



int patch_bsread(int desc,void *data,int elsize,int numel,int byteswap)
{
	int length;
	if (numel == 0) return(0);
	
	switch (elsize)
	{
		case 1:
				length = read(desc,data,numel);
				break;
		case 2:
		case 4:
		case 8:
				length = read(desc,data,numel*elsize);
				if (byteswap) patch_swapbytes(data,elsize,numel);
				break;
	}
	return(length);
}

int patch_bswrite(int desc,void *data,int elsize,int numel,int byteswap)
{
	int length;
	if (numel == 0) return(0);
	
	switch (elsize)
	{
		case 1:
				length = write(desc,data,numel);
				break;
		case 2:
		case 4:
		case 8:
				if (byteswap) patch_swapbytes(data,elsize,numel);
				length = write(desc,data,numel*elsize);
				if (byteswap) patch_swapbytes(data,elsize,numel);
				break;
	}
	return(length);
}


int patch_readheader(int desc,void *data,int nbytes)
{
	int byteswap;
	gdbm_file_header *header;
	avail_block *availblock;
	int  availblocksize;
	int  rbytes = 0;
	
	byteswap = patch_isbyteswap();
	
	header = (gdbm_file_header *) data;
	rbytes += patch_bsread(desc,&(header->header_magic),4,1,byteswap);
	rbytes += patch_bsread(desc,&(header->block_size),4,1,byteswap);
	rbytes += patch_bsread(desc,&(header->dir),8,1,byteswap);
	rbytes += patch_bsread(desc,&(header->dir_size),4,1,byteswap);
	rbytes += patch_bsread(desc,&(header->dir_bits),4,1,byteswap);
	rbytes += patch_bsread(desc,&(header->bucket_size),4,1,byteswap);
	rbytes += patch_bsread(desc,&(header->bucket_elems),4,1,byteswap);
	rbytes += patch_bsread(desc,&(header->next_block),8,1,byteswap);
	
	availblocksize = nbytes - 40;
	availblock = &(header->avail);
	rbytes += patch_readavailblock(desc,availblock,availblocksize);
	
	return(rbytes);
}

int patch_readavailblock(int desc,void *data,int nbytes)
{
	int byteswap;
	avail_block *availblock;
	avail_elem *availelem;
	int rbytes = 0;
	char	*mptr;
	
	byteswap = patch_isbyteswap();
	availblock = (avail_block *) data;
	
	rbytes += patch_bsread(desc,&(availblock->size),4,1,byteswap);
	rbytes += patch_bsread(desc,&(availblock->count),4,1,byteswap);
	rbytes += patch_bsread(desc,&(availblock->next_block),8,1,byteswap);
	
	mptr = (char *) data;
	mptr += 16;
	
	while ((nbytes - rbytes) >= 16)
	{
		availelem = (avail_elem *)mptr;
		mptr += 16;
		
		rbytes += patch_bsread(desc,&(availelem->av_size),4,1,byteswap);
		rbytes += patch_bsread(desc,&(availelem->dummy),4,1,byteswap);
		rbytes += patch_bsread(desc,&(availelem->av_adr),8,1,byteswap);
	}
	
	/* read the remainder of the bytes */
	rbytes += patch_bsread(desc,mptr,1,(nbytes-rbytes),byteswap);
	
	return(rbytes);
}


int patch_readavailtable(int desc,void *data,int nbytes)
{
	int byteswap;
	avail_elem *availelem;
	int rbytes = 0;
	char	*mptr;
	
	byteswap = patch_isbyteswap();
	
	mptr = (char *) data;
	
	while ((nbytes - rbytes) >= 16)
	{
		availelem = (avail_elem *)mptr;
		mptr += 16;
		
		rbytes += patch_bsread(desc,&(availelem->av_size),4,1,byteswap);
		rbytes += patch_bsread(desc,&(availelem->dummy),4,1,byteswap);
		rbytes += patch_bsread(desc,&(availelem->av_adr),8,1,byteswap);
	}
	
	/* read the remainder of the bytes */
	rbytes += patch_bsread(desc,mptr,1,(nbytes-rbytes),byteswap);
	
	return(rbytes);
}


int patch_readhashbucket(int desc,void *data,int nbytes)
{
	int byteswap;
	hash_bucket *hashbucket;
	bucket_element *bucketelement;
	avail_elem *availelem;
	int p;
	int rbytes = 0;
	char	*mptr;
	
	byteswap = patch_isbyteswap();
	hashbucket = (hash_bucket *)data;
	
	rbytes += patch_bsread(desc,&(hashbucket->av_count),4,1,byteswap);
	rbytes += patch_bsread(desc,&(hashbucket->dummy),4,1,byteswap);
	
	mptr = (char *)data;
	mptr += rbytes;
	
	for (p=0;p<BUCKET_AVAIL;p++)
	{
		availelem = (avail_elem *)mptr;
		mptr += sizeof(avail_elem);
		
		rbytes += patch_bsread(desc,&(availelem->av_size),4,1,byteswap);
		rbytes += patch_bsread(desc,&(availelem->dummy),4,1,byteswap);
		rbytes += patch_bsread(desc,&(availelem->av_adr),8,1,byteswap);	
	}
	
	rbytes += patch_bsread(desc,&(hashbucket->bucket_bits),4,1,byteswap);
	rbytes += patch_bsread(desc,&(hashbucket->count),4,1,byteswap);
	
	mptr = (char *)data;
	mptr +=  rbytes;
	while ((nbytes - rbytes) >= (20+SMALL))
	{
		bucketelement = (bucket_element *)mptr;
		mptr += (20+SMALL);
		
		rbytes += patch_bsread(desc,&(bucketelement->hash_value),4,1,byteswap);
		rbytes += patch_bsread(desc,&(bucketelement->key_start),1,SMALL,byteswap);
		rbytes += patch_bsread(desc,&(bucketelement->data_pointer),8,1,byteswap);
		rbytes += patch_bsread(desc,&(bucketelement->key_size),4,1,byteswap);
		rbytes += patch_bsread(desc,&(bucketelement->data_size),4,1,byteswap);
	}

	/* read the remainder of the bytes */
	rbytes += patch_bsread(desc,mptr,1,(nbytes-rbytes),byteswap);

	return(rbytes);	
}

int patch_readdir(int desc,void *data,int nbytes)
{
	int byteswap;
	int  rbytes;
	char *mptr;
	byteswap = patch_isbyteswap();
	rbytes = patch_bsread(desc,data,8,(nbytes/8),byteswap);

	/* read the remainder of the bytes */
	mptr = (char *)data;
	mptr += rbytes;
	rbytes += patch_bsread(desc,mptr,1,(nbytes-rbytes),byteswap);
	
	return(rbytes);
}

int patch_writeheader(int desc,void *data,int nbytes)
{
	int byteswap;
	gdbm_file_header *header;
	avail_block *availblock;
	int  availblocksize;
	int  rbytes = 0;
	
	byteswap = patch_isbyteswap();
	
	header = (gdbm_file_header *) data;
	rbytes = patch_bswrite(desc,&(header->header_magic),4,1,byteswap);
	rbytes += patch_bswrite(desc,&(header->block_size),4,1,byteswap);
	rbytes += patch_bswrite(desc,&(header->dir),8,1,byteswap);
	rbytes += patch_bswrite(desc,&(header->dir_size),4,1,byteswap);
	rbytes += patch_bswrite(desc,&(header->dir_bits),4,1,byteswap);
	rbytes += patch_bswrite(desc,&(header->bucket_size),4,1,byteswap);
	rbytes += patch_bswrite(desc,&(header->bucket_elems),4,1,byteswap);
	rbytes += patch_bswrite(desc,&(header->next_block),8,1,byteswap);
	
	availblocksize = nbytes - rbytes;
	availblock = &(header->avail);
	rbytes += patch_writeavailblock(desc,availblock,availblocksize);
	
	return(rbytes);
}

int patch_writeavailblock(int desc,void *data,int nbytes)
{
	int byteswap;
	avail_block *availblock;
	avail_elem *availelem;
	int rbytes = 0;
	char	*mptr;
	
	byteswap = patch_isbyteswap();
	availblock = (avail_block *)data;
	
	rbytes = patch_bswrite(desc,&(availblock->size),4,1,byteswap);
	rbytes += patch_bswrite(desc,&(availblock->count),4,1,byteswap);
	rbytes += patch_bswrite(desc,&(availblock->next_block),8,1,byteswap);
	
	mptr = (char *)data;
	mptr += rbytes;
	
	while ((nbytes-rbytes) >= sizeof(avail_elem))
	{
		availelem = (avail_elem *)mptr;
		mptr += 16;
		
		rbytes += patch_bswrite(desc,&(availelem->av_size),4,1,byteswap);
		rbytes += patch_bswrite(desc,&(availelem->dummy),4,1,byteswap);
		rbytes += patch_bswrite(desc,&(availelem->av_adr),8,1,byteswap);
	}
	
	/* read the remainder of the bytes */
	rbytes += patch_bswrite(desc,mptr,1,(nbytes-rbytes),byteswap);
	
	return(rbytes);
}

int patch_writehashbucket(int desc,void *data,int nbytes)
{
	int byteswap;
	hash_bucket *hashbucket;
	bucket_element *bucketelement;
	avail_elem *availelem;
	int p;
	int rbytes = 0;
	char	*mptr;
	
	byteswap = patch_isbyteswap();
	hashbucket = (hash_bucket *)data;
	
	rbytes = patch_bswrite(desc,&(hashbucket->av_count),4,1,byteswap);
	rbytes += patch_bswrite(desc,&(hashbucket->dummy),4,1,byteswap);
	
	mptr = (char *)data;
	mptr += rbytes;
	
	for (p=0;p<BUCKET_AVAIL;p++)
	{
		availelem = (avail_elem *)mptr;
		mptr += 16;
		
		rbytes += patch_bswrite(desc,&(availelem->av_size),4,1,byteswap);
		rbytes += patch_bswrite(desc,&(availelem->dummy),4,1,byteswap);
		rbytes += patch_bswrite(desc,&(availelem->av_adr),8,1,byteswap);	
	}
	
	rbytes += patch_bswrite(desc,&(hashbucket->bucket_bits),4,1,byteswap);
	rbytes += patch_bswrite(desc,&(hashbucket->count),4,1,byteswap);
	
	mptr = (char *)data;
	mptr += rbytes;
	
	while (nbytes-rbytes >= (20+SMALL))
	{
		bucketelement = (bucket_element *)mptr;
		mptr += (20+SMALL);
			
		rbytes += patch_bswrite(desc,&(bucketelement->hash_value),4,1,byteswap);
		rbytes += patch_bswrite(desc,&(bucketelement->key_start),1,SMALL,byteswap);
		rbytes += patch_bswrite(desc,&(bucketelement->data_pointer),8,1,byteswap);
		rbytes += patch_bswrite(desc,&(bucketelement->key_size),4,1,byteswap);
		rbytes += patch_bswrite(desc,&(bucketelement->data_size),4,1,byteswap);
	}

	/* read the remainder of the bytes */
	rbytes += patch_bswrite(desc,mptr,1,(nbytes-rbytes),byteswap);

	return(rbytes);	
}


int patch_writedir(int desc,void *data,int nbytes)
{
	int byteswap;
	int  rbytes;
	char *mptr;
	
	byteswap = patch_isbyteswap();
	rbytes = patch_bswrite(desc,data,8,(nbytes/8),byteswap);
	
	/* read the remainder of the bytes */
	mptr = (char *)data;
	mptr += rbytes;
	rbytes += patch_bswrite(desc,mptr,1,(nbytes-rbytes),byteswap);

	
	return(rbytes);
}

